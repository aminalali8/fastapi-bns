# Name of Action
name: Deployment Test

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the "main" branch
  pull_request:
    branches: [ "main" ]
  push: 
    branches: [ "main" ]

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  get-environment: 
    runs-on: ubuntu-latest
    env:
      BNS_HOST: "https://api.environments.bunnyshell.com/api"
    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Setup Python
      - name: setup python
        uses: actions/setup-python@v2
        with:
          python-version: '3.9'
      - name: install dependencies
        run: python -m pip install requests
      - name: get-ephemeral-environment-status
        uses: jannekem/run-python-script-action@v1.2
        with: 
          fail-on-error: true
          script: |
            import requests, os, json, time
            from pprint import pprint
            url = "${{env.BNS_HOST}}/organizations/${{secrets.BNS_ORGID}}/projects/${{secrets.BNS_PROJECTID}}/environments"
            payload={}
            headers = {
                'X-AUTH-TOKEN': '${{secrets.BNS_TOKEN}}'
            }
            env_pending = True
            pr_name = "PR-" + '${{ github.ref }}'.split("/")[2]
            retries = 0
            pprint(pr_name)
            while env_pending :
                response = requests.request("GET", url, headers=headers, data=payload)
                response.raise_for_status()
                environments = json.loads(response.text)['hydra:member']
                # pr_env = list(filter(lambda environment: pr_name in environment['name'] and environment['status'] == 'running' , environments))
                pr_env = list(filter(lambda environment: pr_name in environment['name'] , environments))
                if len(pr_env) > 0:
                  # pprint(pr_env) 
                  # pprint(pr_env[0].get('id'))
                  # os.environ['BNS_ENVID'] = f"{pr_env[0]['id']}"
                  set_env('BNS_ENVID', f'{pr_env[0].get("id")}')
                  break
                else: 
                  time.sleep(10)
            print("Environment ${os.getenv('BNS_ENVID')} is ready.")
      - name: get application url
        uses: jannekem/run-python-script-action@v1.2
        with: 
          fail-on-error: true
          script: |
            import requests, os, json, time
            from pprint import pprint
            envid = os.getenv('BNS_ENVID')
            url = f"${{env.BNS_HOST}}/environments/{envid}/components"
            payload={}
            headers = {
                'X-AUTH-TOKEN': '${{secrets.BNS_TOKEN}}'
            }
            response = requests.request("GET", url, headers=headers, data=payload)
            response.raise_for_status()
            bns_ingress_url = json.loads(response.text)['builtinVariables']
            set_env('APP_URL', bns_ingress_url[next(iter(bns_ingress_url))])
      - name: test application url
        uses: jannekem/run-python-script-action@v1.2
        with: 
          fail-on-error: true
          script: |
            import requests, os, json, time
            from pprint import pprint
            envid = os.getenv('BNS_ENVID')
            url = f"${{env.BNS_HOST}}/environments/{envid}/components"
            payload={}
            headers = {
                'X-AUTH-TOKEN': '${{secrets.BNS_TOKEN}}'
            }
            response = requests.request("GET", url, headers=headers, data=payload)
            response.raise_for_status()
            bns_ingress_url = json.loads(response.text)['builtinVariables']
            set_env('APP_URL', bns_ingress_url[next(iter(bns_ingress_url))])
      - name: print errors
        if: steps.script.outputs.error == 'true'
        run: |
          printenv "SCRIPT_STDOUT"
          printenv "SCRIPT_STDERR"
        env:
          SCRIPT_STDOUT: ${{ steps.script.outputs.stdout }}
          SCRIPT_STDERR: ${{ steps.script.outputs.stderr }} 